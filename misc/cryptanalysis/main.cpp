/** sg41 | Copyright (c) 2021-2022 Hugh Coleman */

#include <iostream>
#include <vector>

using namespace std;

const string R1_LABEL   = "ABCDEFGHIKLMNOPQRSTUVWXYZ";
const string R5_LABEL[] = {
    "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12",
    "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24"
};
const string R6_LABEL[] = {
    "00", "02", "05", "07", "10", "12", "15", "17", "20", "22", "25", "27",
    "30", "32", "35", "37", "40", "42", "45", "47", "50", "52", "55", "57"
};

struct Wheel {
    vector<bool> cams;
    int position = 0;

    void step() {
        position = (position + 1) % cams.size();
    }

    bool peek(int offset) {
        int i = (position - offset) % (int)cams.size();
        if (i < 0)
            i = i + (int)cams.size();

        return cams[i];
    }
};

void wheelset(Wheel wheels[6], vector<int> keystream) {
    // This naive brute-force algorithm attempts to recover the initial wheel
    // positions given (a) the positions of the 144 cams, and (b) a portion of
    // the pseudo-random stream.

#if !defined(DISABLE_OPTIMIZATIONS)
    bool f1 = (
        keystream[0] ==  0 || keystream[0] ==  3 || keystream[0] ==  4 ||
        keystream[0] ==  7 || keystream[0] ==  8 || keystream[0] == 17 ||
        keystream[0] == 18 || keystream[0] == 21 || keystream[0] == 22 ||
        keystream[0] == 25
    );

    bool f2 = (
        keystream[0] ==  1 || keystream[0] ==  2 || keystream[0] ==  5 ||
        keystream[0] ==  6 || keystream[0] ==  9 || keystream[0] == 16 ||
        keystream[0] == 19 || keystream[0] == 20 || keystream[0] == 23 ||
        keystream[0] == 24
    );
#endif

    for (int r1 = 0; r1 < 25; r1++) {
    for (int r2 = 0; r2 < 25; r2++) {
#if !defined(DISABLE_OPTIMIZATIONS)
        // We can reduce the search space, by eliminating partial
        // configurations as early as possible.

        if (f1 && (
            // f1 is truthy iff the first value in the supplied stream can
            // only be created if the left- and second-to-left-most wheels
            // contribute identical values. Thus, we consider both cases for
            // the right-most wheel, and, if both lead to situations where
            // the left- and second-to-left-most wheels contribute differing
            // values, we can reject this r1/r2 starting position pair
            // entirely.

            // Case 1: Wheel 6 is inactive, leading to none of the wheels
            //         stepping in Phases I and II.
            (wheels[0].peek(-8) != wheels[1].peek(-8)) &&

            // Case 2: Wheel 6 is active, leading to the left-most wheel
            //         stepping once, and the second-to-left-most wheel
            //         stepping either once or twice, depending on the state
            //         of the cam at position +5.
            (wheels[0].peek(-7) != wheels[1].peek(-7 - wheels[0].peek(5)))
        )) {
            continue;
        } else if (f2 && (
            // f2 is truthy iff the first value in the supplied stream can
            // only be created if the left- and second-to-left-most wheels
            // contribute differing values. Thus, we consider both cases for
            // the right-most wheel, and, if both lead to situations where
            // the left- and second-to-left-most wheels contribute identical
            // values, we can reject this r1/r2 starting position pair
            // entirely.

            // Case 1: Wheel 6 is inactive, leading to none of the wheels
            //         stepping in Phases I and II.
            (wheels[0].peek(-8) == wheels[1].peek(-8)) &&

            // Case 2: Wheel 6 is active, leading to the left-most wheel
            //         stepping once, and the second-to-left-most wheel
            //         stepping either once or twice, depending on the state
            //         of the cam at position +5.
            (wheels[0].peek(-7) == wheels[1].peek(-7 - wheels[0].peek(5)))
        )) {
            continue;
        }
#endif
    for (int r3 = 0; r3 < 23; r3++) {
    for (int r4 = 0; r4 < 23; r4++) {
    for (int r5 = 0; r5 < 24; r5++) {
    for (int r6 = 0; r6 < 24; r6++) {
        wheels[0].position = r1;
        wheels[1].position = r2;
        wheels[2].position = r3;
        wheels[3].position = r4;
        wheels[4].position = r5;
        wheels[5].position = r6;

        // Now, consider the stream generated by starting
        // in the above configuration.
        for (int kprn : keystream) {
            // Phase I/II
            if (wheels[5].peek(5)) {
                for (int i = 5; i >= 0; --i) {
                    if (i != 0 && wheels[i - 1].peek(5))
                        wheels[i].step();
                    wheels[i].step();
                }
            }

            // Pseudo-random Number Generation
            bool invert = wheels[5].peek(-8);
            int gprn = (
                (invert ^ wheels[0].peek(-8)) * 1  +
                (invert ^ wheels[1].peek(-8)) * 2  +
                (invert ^ wheels[2].peek(-8)) * 4  +
                (invert ^ wheels[3].peek(-8)) * 8  +
                (invert ^ wheels[4].peek(-8)) * 10
            );

            if (kprn != gprn) goto invalid;

            // Phase III/Phase IV
            for (int i = 5; i >= 0; --i) {
                if (i != 0 && wheels[i - 1].peek(5))
                    wheels[i].step();
                wheels[i].step();
            }
        }

        cout << R1_LABEL[r1] << " "
             << R1_LABEL[r2] << " "
             << R1_LABEL[r3] << " "
             << R1_LABEL[r4] << " "
             << R5_LABEL[r5] << " "
             << R6_LABEL[r6] << endl;

        invalid:
        ;
    }
    }
    }
    }
    }
    }

    return;
}

int main() {
    Wheel wheels[6]{
        Wheel{ .cams = vector<bool>{ 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1 } },
        Wheel{ .cams = vector<bool>{ 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0 } },
        Wheel{ .cams = vector<bool>{ 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0       } },
        Wheel{ .cams = vector<bool>{ 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0       } },
        Wheel{ .cams = vector<bool>{ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0    } },
        Wheel{ .cams = vector<bool>{ 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0    } }
    };

    vector<int> keystream{
         6,  6,  2,  9, 11,  3, 13, 25, 23, 16,  6, 13, 18, 23, 11,  3, 10,
        25,  0, 11, 15,  7, 25, 15,  4,  0,  1,  9, 13, 12, 23, 9
    };

    wheelset(wheels, keystream);
}
